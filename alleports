#!/usr/bin/env python3
import argparse
import subprocess
import sys
import shutil
import os
import re
import tempfile
import warnings
import xml.etree.ElementTree as ET
from rich.console import Console
from rich.table import Table
from rich import box
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeRemainingColumn

# Suppress SSL warnings for HTTP header analysis
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

console = Console()

class AllePorts:
    def __init__(self, target, mode="default", no_udp=False):
        self.target = target
        self.mode = mode
        self.no_udp = no_udp
        self.results = {} # Key: (port, protocol), Value: port_info dict
        self.nmap_path = shutil.which("nmap")
        
        if not self.nmap_path:
            console.print("[bold red]Error:[/bold red] nmap is not installed or not in PATH.")
            sys.exit(1)
            
        if os.geteuid() != 0:
            console.print("[bold yellow]Warning:[/bold yellow] You are not running as root. Some scans (like SYN scan or UDP scan) may fail or fall back to connect scan.")

    def scan(self):
        console.print(f"[bold blue]AllePorts: Starting scan on {self.target} in {self.mode} mode...[/bold blue]")
        
        if self.mode == "fast":
            self._scan_fast()
        elif self.mode == "slow":
            self._scan_slow()
        else:
            self._scan_default()

        # Smart Retry Logic for filtered ports
        # Identify ports that are currently filtered
        filtered = [p for k, p in self.results.items() if p['state'] in ['filtered', 'open|filtered']]
        
        if filtered:
             self._retry_smart_exhaustive(filtered)
        
        self._print_report()

    def _detect_firewall(self):
        """Detect firewall presence and type using ACK scan."""
        console.print("\n[dim]Analyzing firewall configuration...[/dim]")
        
        # Select test ports: mix of common and random
        test_ports = "80,443,22,3389,135,1234,9999,31337"
        
        result = self._run_nmap(["-sA", "-p", test_ports, "-Pn", "-T4"], 
                                "Firewall Detection (ACK Scan)")
        
        if not result:
            return {'present': False, 'type': 'unknown', 'filtering': 'none'}
        
        # Parse results
        filtered_count = 0
        unfiltered_count = 0
        
        for port_info in self.results.values():
            state = port_info.get('state', '')
            if state == 'filtered':
                filtered_count += 1
            elif state == 'unfiltered':
                unfiltered_count += 1
        
        total = filtered_count + unfiltered_count
        if total == 0:
            return {'present': False, 'type': 'unknown', 'filtering': 'none'}
        
        filter_ratio = filtered_count / total
        
        # Analysis
        if filter_ratio > 0.8:
            fw_type = 'stateful'
            filtering = 'aggressive'
        elif filter_ratio > 0.3:
            fw_type = 'stateful'
            filtering = 'moderate'
        elif filter_ratio > 0:
            fw_type = 'stateless'
            filtering = 'minimal'
        else:
            return {'present': False, 'type': 'none', 'filtering': 'none'}
        
        console.print(f"[bold yellow]Firewall detected: {fw_type} ({filtering} filtering)[/bold yellow]")
        
        return {
            'present': True,
            'type': fw_type,
            'filtering': filtering,
            'filter_ratio': filter_ratio
        }

    def _analyze_http_headers(self):
        """Extract OS from HTTP headers - most reliable for external networks."""
        # Check if 80 or 443 is open
        http_ports = []
        for (port, proto), info in self.results.items():
            if info['state'] == 'open' and port in ['80', '443', '8080', '8443']:
                http_ports.append(port)
        
        if not http_ports:
            return None
        
        # Try HTTP request
        for port in http_ports:
            try:
                import requests
                protocol = 'https' if port in ['443', '8443'] else 'http'
                url = f"{protocol}://{self.target}:{port}"
                
                response = requests.get(url, timeout=5, verify=False, 
                                       headers={'User-Agent': 'Mozilla/5.0'})
                
                headers = response.headers
                headers_str = str(headers).lower()
                
                # Windows indicators
                if any(x in headers_str for x in ['microsoft-iis', 'asp.net', 'windows']):
                    return 'windows', 95
                
                # Linux indicators
                if any(x in headers_str for x in ['ubuntu', 'debian', 'centos', 'red hat', 'fedora']):
                    return 'linux', 95
                
                # Server header analysis
                server = headers.get('Server', '').lower()
                if 'apache' in server or 'nginx' in server:
                    return 'linux', 75
                elif 'iis' in server:
                    return 'windows', 90
                    
            except:
                continue
        
        return None

    def _analyze_service_banners(self):
        """Enhanced banner analysis with version parsing."""
        os_votes = {'windows': 0, 'linux': 0}
        
        for port_info in self.results.values():
            if port_info['state'] != 'open':
                continue
                
            service = port_info.get('service', '').lower()
            
            # Strong indicators
            if any(x in service for x in ['ubuntu', 'debian', 'centos', 'red hat', 'fedora']):
                os_votes['linux'] += 5
            elif any(x in service for x in ['microsoft', 'windows', 'win32']):
                os_votes['windows'] += 5
            
            # Port-specific patterns
            port = port_info['port']
            if port == '22' and 'openssh' in service:
                os_votes['linux'] += 3
            elif port in ['135', '139', '445', '3389']:
                os_votes['windows'] += 4
        
        if os_votes['windows'] > os_votes['linux']:
            confidence = min(90, 60 + os_votes['windows'] * 5)
            return 'windows', confidence
        elif os_votes['linux'] > os_votes['windows']:
            confidence = min(90, 60 + os_votes['linux'] * 5)
            return 'linux', confidence
        
        return None

    def _nmap_os_detection_standard(self):
        """Standard Nmap OS detection for clean targets."""
        result = self._run_nmap(["-O", "--osscan-limit", "-Pn", "-T4"], 
                                "Standard OS Detection")
        return self._parse_os_from_xml(result) if result else None

    def _nmap_os_detection_aggressive(self):
        """Aggressive Nmap OS detection for firewalled targets."""
        result = self._run_nmap(["-O", "--osscan-guess", "--max-os-tries", "2", "-Pn", "-T4"], 
                                "Aggressive OS Detection")
        return self._parse_os_from_xml(result) if result else None

    def _parse_os_from_xml(self, xml_root):
        """Extract OS classification from Nmap XML output."""
        if xml_root is None:
            return None
        
        try:
            for host in xml_root.findall("host"):
                os_elem = host.find("os")
                if os_elem is not None:
                    osmatch = os_elem.find("osmatch")
                    if osmatch is not None:
                        os_name = osmatch.get("name", "").lower()
                        
                        if "windows" in os_name:
                            return "windows"
                        elif any(x in os_name for x in ["linux", "ubuntu", "debian", "centos", "fedora"]):
                            return "linux"
                        elif any(x in os_name for x in ["bsd", "freebsd", "openbsd"]):
                            return "bsd"
                        elif "unix" in os_name:
                            return "unix"
        except:
            pass
        
        return None

    def _guess_os_from_firewall(self, fw_profile):
        """Heuristic: Some firewall behaviors indicate OS."""
        open_windows_ports = sum(1 for p in self.results.values() 
                                 if p['state'] == 'open' 
                                 and p['port'] in ['135', '139', '445', '3389'])
        
        if open_windows_ports >= 2:
            return 'windows'
        
        return None

    def _detect_os_intelligent(self, fw_profile):
        """Firewall-aware OS detection with multi-layer approach."""
        detections = []
        
        # Layer 1: HTTP Headers (highest priority)
        http_result = self._analyze_http_headers()
        if http_result:
            os_type, conf = http_result
            detections.append(('http', os_type, conf))
            console.print(f"[dim green]HTTP headers indicate: {os_type} ({conf}%)[/dim green]")
        
        # Layer 2: Service Banners
        banner_result = self._analyze_service_banners()
        if banner_result:
            os_type, conf = banner_result
            detections.append(('banner', os_type, conf))
            console.print(f"[dim green]Service banners indicate: {os_type} ({conf}%)[/dim green]")
        
        # Layer 3: Nmap -O (adaptive based on firewall)
        nmap_os = None
        if fw_profile['present']:
            if fw_profile['filtering'] == 'aggressive':
                console.print("[dim yellow]Heavy firewall - skipping Nmap OS scan[/dim yellow]")
            else:
                nmap_os = self._nmap_os_detection_aggressive()
        else:
            nmap_os = self._nmap_os_detection_standard()
        
        if nmap_os:
            confidence = 80 if not fw_profile['present'] else 50
            detections.append(('nmap', nmap_os, confidence))
            console.print(f"[dim green]Nmap detection: {nmap_os} ({confidence}%)[/dim green]")
        
        # Layer 4: Firewall behavior
        if fw_profile['present']:
            fw_os = self._guess_os_from_firewall(fw_profile)
            if fw_os:
                detections.append(('firewall', fw_os, 40))
        
        # Weighted voting
        if not detections:
            return 'unknown', 0
        
        # If HTTP headers found something with high confidence, trust it
        if detections and detections[0][0] == 'http' and detections[0][2] >= 90:
            return detections[0][1], detections[0][2]
        
        # Otherwise aggregate
        votes = {}
        for source, os_type, confidence in detections:
            votes[os_type] = votes.get(os_type, 0) + confidence
        
        winner = max(votes, key=votes.get)
        matching_detections = [d for d in detections if d[1] == winner]
        avg_confidence = int(votes[winner] / len(matching_detections)) if matching_detections else 0
        
        return winner, min(95, avg_confidence)

    def _get_scan_sequence(self, os_type):
        """Returns optimal scan order for OS - ACK removed from retry."""
        if os_type == 'linux':
            return [
                (["-sF", "-Pn", "-T4"], "FIN Scan"),
                (["-sN", "-Pn", "-T4"], "Null Scan"),
                (["-sX", "-Pn", "-T4"], "Xmas Scan"),
                (["-sM", "-Pn", "-T4"], "Maimon Scan"),
            ]
        elif os_type == 'windows':
            console.print("[yellow]Windows detected - filtered ports harder to unmask[/yellow]")
            return [
                (["-sW", "-Pn", "-T4"], "Window Scan"),
                (["-sF", "-Pn", "-T4"], "FIN Scan"),
                (["-sN", "-Pn", "-T4"], "Null Scan"),
            ]
        else:
            return [
                (["-sW", "-Pn", "-T4"], "Window Scan"),
                (["-sF", "-Pn", "-T4"], "FIN Scan"),
                (["-sN", "-Pn", "-T4"], "Null Scan"),
                (["-sX", "-Pn", "-T4"], "Xmas Scan"),
            ]

    def _get_still_filtered(self, port_list):
        """Returns ports that are still filtered/open|filtered."""
        still_filtered = []
        
        for port in port_list:
            for (p, proto), info in self.results.items():
                if p == port and info['state'] in ['filtered', 'open|filtered']:
                    still_filtered.append(info)
                    break
        
        return still_filtered

    def _retry_smart_exhaustive(self, filtered_ports):
        """Exhaustive but optimized retry - zero port loss guarantee."""
        
        # Step 1: Firewall profiling
        fw_profile = self._detect_firewall()
        
        # Step 2: OS Detection
        os_type, confidence = self._detect_os_intelligent(fw_profile)
        
        console.print(f"\n[bold green]Smart Retry Strategy:[/bold green]")
        console.print(f"  Target OS: [cyan]{os_type}[/cyan] (confidence: {confidence}%)")
        console.print(f"  Firewall: [yellow]{fw_profile['type']}[/yellow] ({fw_profile['filtering']} filtering)")
        console.print(f"  Initial filtered ports: [red]{len(filtered_ports)}[/red]\n")
        
        # Step 3: Get OS-specific scan sequence
        scan_sequence = self._get_scan_sequence(os_type)
        
        # Step 4: Incremental scanning with batch processing
        remaining_filtered = [p for p in filtered_ports]
        total_rescued = 0
        
        console.print(f"[bold yellow]Processing {len(remaining_filtered)} filtered ports...[/bold yellow]\n")
        
        for idx, (flags, description) in enumerate(scan_sequence, 1):
            if not remaining_filtered:
                console.print(f"[bold green]✓ All filtered ports resolved![/bold green]")
                break
            
            # Batch processing: 200 port chunks
            rescued_this_round = 0
            
            for batch_start in range(0, len(remaining_filtered), 200):
                batch = remaining_filtered[batch_start:batch_start + 200]
                port_list = [p['port'] for p in batch]
                port_arg = ",".join(port_list)
                
                batch_info = f"batch {batch_start//200 + 1}/{(len(remaining_filtered)-1)//200 + 1}" if len(remaining_filtered) > 200 else ""
                console.print(f"[dim]Scan {idx}/{len(scan_sequence)}: {description} - {len(port_list)} ports {batch_info}[/dim]")
                
                # Run scan
                self._run_nmap(flags + ["-p", port_arg], description)
            
            # After all batches, recalculate what's still filtered
            new_remaining = []
            for p in remaining_filtered:
                key = (p['port'], p['protocol'])
                current_state = self.results.get(key, {}).get('state', 'filtered')
                
                if current_state in ['filtered', 'open|filtered']:
                    new_remaining.append(p)
            
            rescued = len(remaining_filtered) - len(new_remaining)
            total_rescued += rescued
            
            if rescued > 0:
                console.print(f"[bold green]  ✓ {rescued} port(s) unmasked[/bold green]")
            else:
                console.print(f"[dim]  → No change[/dim]")
            
            remaining_filtered = new_remaining
        
        # Final report
        console.print(f"\n[bold cyan]═══ Smart Retry Complete ═══[/bold cyan]")
        console.print(f"  Scans executed: [cyan]{idx}[/cyan]")
        console.print(f"  Ports rescued: [green]{total_rescued}[/green]")
        console.print(f"  Still filtered: [yellow]{len(remaining_filtered)}[/yellow]")
        
        if remaining_filtered:
            console.print(f"\n[dim]Note: {len(remaining_filtered)} ports remain filtered (likely truly blocked)[/dim]")

    def _run_nmap(self, args, description):
        """Runs nmap with provided args and returns parsed XML root or None."""
        # Create a temp file for XML output
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.xml') as tmp_xml:
            tmp_xml_path = tmp_xml.name
            
            
        # Add basic flags: output to XML file, stats every 1s
        cmd = [self.nmap_path, "-oX", tmp_xml_path, "--stats-every", "1s"] + args + [self.target]
        
        # Enhanced Description with Flags
        flags_str = " ".join(args)
        full_desc = f"{description} [dim green]({flags_str})[/dim green]"
        
        # Setup Rich Progress Bar (Matrix Style)
        with Progress(
            SpinnerColumn(style="bold green"),
            TextColumn("[bold green]{task.description}"),
            BarColumn(bar_width=None, style="green", complete_style="bold green", finished_style="bold green"),
            TextColumn("[bold green]{task.percentage:>3.0f}%"),
            TimeRemainingColumn(),
            console=console,
            transient=True 
        ) as progress:
            task_id = progress.add_task(full_desc, total=100)
            
            try:
                # Merge stdout and stderr to capture stats
                process = subprocess.Popen(
                    cmd, 
                    stdout=subprocess.PIPE, 
                    stderr=subprocess.STDOUT, 
                    universal_newlines=True,
                    bufsize=1
                )
                
                # Check for 100% manually to ensure bar completes
                completed = False
                
                while True:
                    output = process.stdout.readline()
                    if output == '' and process.poll() is not None:
                        break
                    if output:
                        # Regex to parse Nmap stats: "About 5.00% done; ETC: 12:00 (0:00:45 remaining)"
                        # Example: "SYN Stealth Scan Timing: About 1.50% done; ETC: 12:16 (0:01:06 remaining)"
                        match = re.search(r"About\s+(\d+\.\d+)%\s+done", output)
                        if match:
                            percent = float(match.group(1))
                            progress.update(task_id, completed=percent)
                            if percent >= 99.9:
                                completed = True
                                
                process.wait()
                if not completed and process.returncode == 0:
                     progress.update(task_id, completed=100)

            except FileNotFoundError:
                 console.print("[bold red]Error:[/bold red] Nmap binary not found during execution.")
                 return None
            except Exception as e:
                console.print(f"[bold red]Unexpected error:[/bold red] {e}")
                return None
        
        # Check return code
        if process.returncode != 0:
            # We already consumed stdout/stderr, so we can't easily print it unless we stored it.
            # But usually if nmap fails, it prints something before exiting.
            console.print(f"[dim green]Nmap process finished with exit code {process.returncode}[/dim green]")

        # Read and parse XML
        try:
            with open(tmp_xml_path, 'r') as f:
                xml_content = f.read()
            return self._parse_xml(xml_content)
        except Exception as e:
            console.print(f"[bold red]Error reading scan results:[/bold red] {e}")
            return None
        finally:
            if os.path.exists(tmp_xml_path):
                os.remove(tmp_xml_path)

    def _parse_xml(self, xml_content):
        if not xml_content: return None
        try:
            root = ET.fromstring(xml_content)
            for host in root.findall("host"):
                ports_elem = host.find("ports")
                if ports_elem:
                    for port_elem in ports_elem.findall("port"):
                        port_id = port_elem.get("portid")
                        protocol = port_elem.get("protocol")
                        state_elem = port_elem.find("state")
                        state = state_elem.get("state") if state_elem is not None else "unknown"
                        reason = state_elem.get("reason") if state_elem is not None else ""
                        
                        service_elem = port_elem.find("service")
                        service = service_elem.get("name") if service_elem is not None else "unknown"
                        
                        port_info = {
                            "port": port_id, 
                            "protocol": protocol, 
                            "state": state, 
                            "service": service,
                            "reason": reason
                        }
                        
                        key = (port_id, protocol)
                        
                        # Priority: open > closed > unfiltered > filtered
                        priority_map = {
                            "open": 4,
                            "closed": 3,
                            "unfiltered": 2,
                            "open|filtered": 1,
                            "filtered": 0
                        }
                        
                        existing = self.results.get(key)
                        new_priority = priority_map.get(state, 0)
                        old_priority = priority_map.get(existing['state'], 0) if existing else -1
                        
                        if new_priority > old_priority:
                            self.results[key] = port_info
                        elif new_priority == old_priority and "reason" in port_info and port_info['reason']:
                             # Update detail if same state but potentially better reason
                             self.results[key] = port_info

            return root
        except ET.ParseError:
            console.print("[bold red]Error parsing Nmap XML output[/bold red]")
            return None

    def _scan_fast(self):
        # Fast: Top 100 TCP & UDP
        # Command: nmap -F -sS -sU -sV <target>
        
        flags = ["-F", "-sV"]
        desc = "Fast Scan"
        
        # Check permissions and user preference for UDP
        use_udp = (os.geteuid() == 0) and (not self.no_udp)
        
        if os.geteuid() == 0:
            flags.append("-sS")
            if use_udp:
                flags.append("-sU")
                desc = "Fast Scan (TCP/UDP)"
            else:
                 console.print("[dim green]Skipping UDP (requested or non-root)[/dim green]")
        else:
            flags.append("-sT") # Connect scan
            console.print("[dim green]Non-root: Skipping UDP and using Connect Scan (-sT)[/dim green]")
            
        self._run_nmap(flags, desc)

    def _scan_default(self):
        # Default: TCP All, UDP Top 20
        
        # 1. TCP All
        console.print("[bold green]Step 1/2: Scanning all TCP ports...[/bold green]")
        tcp_flags = ["-p-", "-sV", "-T4"]
        if os.geteuid() == 0:
            tcp_flags.append("-sS")
        else:
            tcp_flags.append("-sT")
            
        self._run_nmap(tcp_flags, "TCP All-Port Scan")
        
        # 2. UDP Top 20
        use_udp = (os.geteuid() == 0) and (not self.no_udp)
        
        if use_udp:
            console.print("[bold green]Step 2/2: Scanning top 20 UDP ports...[/bold green]")
            self._run_nmap(["-sU", "--top-ports", "20", "-sV"], "UDP Top 20 Scan")
        else:
             if self.no_udp:
                console.print("[dim green]Skipping UDP scan (--no-udp specified)[/dim green]")
             else:
                console.print("[dim green]Skipping UDP scan (requires root)[/dim green]")

    def _scan_slow(self):
        # Slow: TCP All, UDP All
        
        # 1. TCP All
        console.print("[bold green]Step 1/2: Scanning all TCP ports...[/bold green]")
        tcp_flags = ["-p-", "-sV", "-T4"]
        if os.geteuid() == 0:
            tcp_flags.append("-sS")
        else:
            tcp_flags.append("-sT")

        self._run_nmap(tcp_flags, "TCP All-Port Scan")
        
        # 2. UDP All
        use_udp = (os.geteuid() == 0) and (not self.no_udp)
        
        if use_udp:
            console.print("[bold green]Step 2/2: Scanning all UDP ports (This will take a long time)...[/bold green]")
            self._run_nmap(["-sU", "-p-", "-sV", "-T4"], "UDP All-Port Scan")
        else:
            if self.no_udp:
                console.print("[dim green]Skipping UDP scan (--no-udp specified)[/dim green]")
            else:
                console.print("[dim green]Skipping UDP scan (requires root)[/dim green]")

    def _print_report(self):
        console.print("\n")
        # Matrix Style: No header borders, minimal lines, Green text.
        table = Table(
            title=f"AllePorts Analysis: {self.target}", 
            show_header=True, 
            header_style="bold black on green",
            box=box.SIMPLE, # Minimal box
            border_style="green",
            title_style="bold green"
        )
        table.add_column("PORT", justify="right", style="bold green")
        table.add_column("PROTO", style="green")
        table.add_column("STATE", justify="center")
        table.add_column("SERVICE", style="green")
        table.add_column("VERSION/REASON", style="dim green")

        # Sort by port number
        sorted_ports = sorted(self.results.values(), key=lambda x: int(x['port']))

        if not sorted_ports:
            console.print("[green]No interesting ports found.[/green]")
            return

        for p in sorted_ports:
            state = p['state']
            if "open" in state and "filtered" not in state:
                state_fmt = f"[bold green]{state.upper()}[/bold green]"
            elif "filtered" in state:
                state_fmt = f"[bold yellow]{state.upper()}[/bold yellow]"
            elif "closed" in state:
                state_fmt = f"[bold red]{state.upper()}[/bold red]"
            elif "unfiltered" in state:
                state_fmt = f"[bold white]{state.upper()}[/bold white]"
            else:
                state_fmt = f"[green]{state}[/green]"

            table.add_row(p['port'], p['protocol'], state_fmt, p['service'], p.get('reason', ''))

        console.print(table)
        
        # Summary stats
        # Summary stats
        state_counts = {}
        for p in self.results.values():
            s = p['state']
            state_counts[s] = state_counts.get(s, 0) + 1
            
        summary_parts = []
        # Sort order: open, open|filtered, filtered, closed|filtered, closed, unfiltered
        pm = {"open": 0, "open|filtered": 1, "filtered": 2, "closed|filtered": 3, "closed": 4, "unfiltered": 5}
        
        for state, count in sorted(state_counts.items(), key=lambda x: pm.get(x[0], 99)):
            state_upper = state.upper()
            if "open" in state and "filtered" not in state:
                style = "bold green"
            elif "filtered" in state:
                style = "bold yellow"
            elif "closed" in state:
                style = "bold red"
            else:
                style = "bold white"
                
            summary_parts.append(f"[{style}]{count} {state_upper}[/{style}]")
            
        if summary_parts:
             console.print(f"\n[bold]Scan Summary:[/bold] {' | '.join(summary_parts)}")
        else:
             console.print("\n[bold]Scan Summary:[/bold] No results.")

def main():
    parser = argparse.ArgumentParser(description="AllePorts - Advanced Smart Port Scanner")
    parser.add_argument("target", help="Target IP or hostname")
    parser.add_argument("--mode", choices=["fast", "default", "slow"], default="default", help="Scan mode")
    parser.add_argument("--no-udp", action="store_true", help="Disable UDP scanning completely")
    
    # Allow passing through nmap args? For now, keep it simple as per request.
    
    args = parser.parse_args()

    scanner = AllePorts(args.target, args.mode, args.no_udp)
    scanner.scan()

if __name__ == "__main__":
    main()
